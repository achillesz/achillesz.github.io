<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>febbc</title>
  <link href="//achillesz.github.io//atom.xml" rel="self"/>
  <link href="//achillesz.github.io"/>
  <updated>2016-03-26T11:21:04+08:00</updated>
  <id>//achillesz.github.io</id>
  <author>
    <name>achilles</name>
  </author>

  
  <entry>
    <title>linux edit</title>
    <link href="//achillesz.github.io/linux/2016/03/24/edit-vim.html"/>
    <updated>2016-03-24T16:51:36+08:00</updated>
    <id>//achillesz.github.io/linux/2016/03/24/edit-vim</id>
    <content type="html">edit 编辑已经存在的文件

edit 编辑相对目录文件

edit % 展开当前文件路径
</content>
  </entry>
  
  <entry>
    <title>html引号转义问题</title>
    <link href="//achillesz.github.io/js/2016/01/29/quote.html"/>
    <updated>2016-01-29T19:41:11+08:00</updated>
    <id>//achillesz.github.io/js/2016/01/29/quote</id>
    <content type="html">描述：


  
    html标签属性一般是双引号，也可以用单引号。 这样要求中间内容不能添加相同的引号。 
目前产品线上，产品名显示的时候 都是这样 &amp;lt;input id=&quot;aaaa&quot; type=&quot;text&quot; value=&#39;sdffdf&#39;/&amp;gt;
双引号的时候也不会有问题，但是有海外的产品录入，都成了英文了，会有单引号的问题。这个无法解决。也无法克服。对于JS的反斜杠转义在这里没有任何作用。。
  
  
    第二种是我们经常从这种input 框里取数据，然后要JSON.parse 操作。 它要求属性用单引号，里面的对象用双引号，中间也确实可以加反斜杠，因为JS读取的时候...</content>
  </entry>
  
  <entry>
    <title>Component介绍</title>
    <link href="//achillesz.github.io/js/2016/01/26/component.html"/>
    <updated>2016-01-26T19:41:11+08:00</updated>
    <id>//achillesz.github.io/js/2016/01/26/component</id>
    <content type="html">类说明

	$.ui.Component = function(opt_doc) {
		this.document_ = opt_doc || window.document;
	};



new 的时候保存一个所在文档的属性

方法说明：

createElement

	return $(html, this.document_);


当前文档下创建DOM元素,这么看涉及到 createDom 的时候还是应该用 createElement, 也可以 createDom 继承一下，走默认调用，确保在正确的文档里

createDom

	this.element_ = this....</content>
  </entry>
  
  <entry>
    <title>git 删除远程分支</title>
    <link href="//achillesz.github.io/git/2016/01/12/delete-branch.html"/>
    <updated>2016-01-12T03:16:11+08:00</updated>
    <id>//achillesz.github.io/git/2016/01/12/delete-branch</id>
    <content type="html">	git push origin :needDelBranchName



如何理解：
text
	git push origin serverfix:serverfix 
    git push origin refs/heads/serverfix:refs/heads/serverfix


git push [远程名] [本地分支]:[远程分支]

如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]

	git fetch [remote-name]



此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓...</content>
  </entry>
  
  <entry>
    <title>git 创建分支命令</title>
    <link href="//achillesz.github.io/git/2016/01/11/create-branch.html"/>
    <updated>2016-01-11T23:12:11+08:00</updated>
    <id>//achillesz.github.io/git/2016/01/11/create-branch</id>
    <content type="html">
  先切换到主分支（一般从master新建分支）
  新建并切换到分支
  分支push到远程
  建立关联


	git checkout master
	git checkout -b branchName
	git push origin branchName
	git branch --set-upstream-to=origin/0111-marketing branchName



这样以后就可以 pull/push 直接拉/推 了。

至于上面几个命令的理解：

	git checkout -b [分支名] [远程名]/[分支名]
    git checkout -b...</content>
  </entry>
  
  <entry>
    <title>linux 移动操作</title>
    <link href="//achillesz.github.io/linux/2015/12/29/vim-move.html"/>
    <updated>2015-12-29T04:51:36+08:00</updated>
    <id>//achillesz.github.io/linux/2015/12/29/vim-move</id>
    <content type="html">半屏
control+U :文本向上滚半屏
control+D :文本向下滚半屏

一行
control+E :文本向下滚动一行
control+Y :文本向上滚动一行

翻页
control+F :文本向下滚动一屏,实际上是整屏减去2行。
control+b :文本向上滚动一屏，同上。

位置

zz 把当前行置为屏幕的中央

zt 把当前行置于屏幕的顶端

zb 把当前行置于屏幕的底端

文本对象
iw 当前单词

aw 当前单子以及一个空格

is 当前句子

as 当前句子以及一个空格

ip 当前段落

ap 当前段落及一个空格

it 标签内部的内容

i“ 引号内部的内容
...</content>
  </entry>
  
  <entry>
    <title>chrome 您的链接不是私密链接</title>
    <link href="//achillesz.github.io/chrome/2015/12/28/deferred.html"/>
    <updated>2015-12-28T18:51:36+08:00</updated>
    <id>//achillesz.github.io/chrome/2015/12/28/deferred</id>
    <content type="html">1.打开chrome://flags
2.找到“允许来自https来源的不安全WebSocket”
3.点启用，然后重启浏览器

</content>
  </entry>
  
  <entry>
    <title>define</title>
    <link href="//achillesz.github.io/ext/2015/11/05/define.html"/>
    <updated>2015-11-05T02:11:36+08:00</updated>
    <id>//achillesz.github.io/ext/2015/11/05/define</id>
    <content type="html">apply此处的一个作用只是把arguments 完全拿过来使用，以符合参数的格式，而作用域本来就是 Manager
显然用到了 apply, 也用到了 Manager

	Ext.apply(Ext,{
	define: functionL() {}
	})



	define: function (className, data, createdFn) {
		if (data.override) {
			return Manager.createOverride.apply(Manager, arguments);
		}

		return Manager.create.ap...</content>
  </entry>
  
  <entry>
    <title>Callbacks模块解析</title>
    <link href="//achillesz.github.io/jquery/2015/10/28/CallBacks.html"/>
    <updated>2015-10-28T02:11:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/10/28/CallBacks</id>
    <content type="html">某个时候调用某个函数，这个函数被称作回调函数。

某个时候，要干某些事情，某些事情分别由不同的函数来完成，并且应该有先后顺序。

回调列表就是用来解决这个问题的。


  add的函数，被放在LIST列表，调用的时候遍历，按照添加的先后顺序依次调用各函数，注意某个时候，参数是相同的，执行所有的函数一遍
  如果add的时候，调用已经结束，且是 memory 的情况下，那么直接执行。 否则不执行。
  如果在调用中，又add， 那么应该把该函数，添加到执行队列中去。执行过去的时候会执行到。具体是直接设置循环的长度，就会读到新增的条目。
  如果在某个状态的调用中，又有某个状态要反复调用，那...</content>
  </entry>
  
  <entry>
    <title>eq pushStack merge</title>
    <link href="//achillesz.github.io/jquery/2015/10/01/eq.html"/>
    <updated>2015-10-01T02:31:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/10/01/eq</id>
    <content type="html">
  传入正数
  传入负数


最终得到类数组的某一项，然后放入数组

	eq: function(i) {
		var len = this.length,
			j = +i + (i &amp;lt; 0 ? len : 0);
		return this.pushStack(j &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; len ? [this[j]] : []);
	},



pushStack 用来返回新生成的对象，并且保存了 preObject 原来对象的属性

大体操作过程传入这个elems,是个放在数组里的DOM元素，就是数组。

然后把它变成jQuery对象，为啥...</content>
  </entry>
  
  <entry>
    <title>类型判断</title>
    <link href="//achillesz.github.io/jquery/2015/09/25/istypes.html"/>
    <updated>2015-09-25T18:53:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/09/25/istypes</id>
    <content type="html">静态方法type

空对象toString的函数会返回一个


  
    
      obj
      result1
    
  
  
    
      字符窜
      [object String]
    
    
      函数
      [object Function]
    
  


我们知道类型返回的结果，JQ 把它作为KEY，值简化成一个直观的小写。

	jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), functi...</content>
  </entry>
  
  <entry>
    <title>trim的实现</title>
    <link href="//achillesz.github.io/jquery/2015/09/25/trim.html"/>
    <updated>2015-09-25T04:54:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/09/25/trim</id>
    <content type="html">下面应该是不做兼容处理的。


	trim: function(text) {
		return text == null ? &quot;&quot; : core_trim.call(text);
	}




而下面的代码是早期的：

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	trim = String.prototype.trim




	trim: trim ?
		function( text ) {
			return text == null ?
				&quot;&quot; :
				trim...</content>
  </entry>
  
  <entry>
    <title>proxy的使用</title>
    <link href="//achillesz.github.io/jquery/2015/09/24/proxy.html"/>
    <updated>2015-09-24T01:54:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/09/24/proxy</id>
    <content type="html">假设有一个函数要被调用，this应该指向正确的context(上下文)，但在某些环境下this另有它指，破坏了我们期望的this。这种场景有几种：


  事件函数中，被指向dom元素
  each函数中，被指向为dom元素
  定时器函数中，被指向window


以上几个场景会破坏掉面向对象的this,我们的目标是这个函数被执行时this指向正确的上下文。
而实际上，是包装了一层函数，这层函数的上下文不被关心，而我们真正的函数被触发时候，会指向正确的上下文。


 		proxy: function(fn, context) {
            var tmp, args, ...</content>
  </entry>
  
  <entry>
    <title>noConflict函数干的事</title>
    <link href="//achillesz.github.io/jquery/2015/09/23/noconflict1.html"/>
    <updated>2015-09-23T23:37:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/09/23/noconflict1</id>
    <content type="html">在拉入我们的库运行的时候，我们会暴露两个变量来使用我们的库，但也许我们之前，别人已经叫过这个名字了。那怎么办？

我们先保存别人的这个变量，我们通过一个方法，来还原别人的变量，而自己的，保存到用户自定义的变量里。


	noConflict: function(deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep &amp;amp;&amp;amp; window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	}



...</content>
  </entry>
  
  <entry>
    <title>jQuery blur事件绑定不上</title>
    <link href="//achillesz.github.io/jquery/2015/09/18/blur.html"/>
    <updated>2015-09-18T19:38:36+08:00</updated>
    <id>//achillesz.github.io/jquery/2015/09/18/blur</id>
    <content type="html">在一个ifram里面弹出到父级窗口的dialog窗口中,做手机，邮箱的校验。但是发现无效。


	var jv = this.form.jvalidator();
	jv.when([&#39;blur&#39;]);
	jv.success(function() {
		var $el = this.$element;
		$el.removeClass(&#39;red_border&#39;);
	});

	jv.fail(function() {
		var $el = this.$element;
		$el.addClass(&#39;red_border&#39;);
	});
	



经过一顿排查发现某个地方的代码...</content>
  </entry>
  
  <entry>
    <title>js继承解释</title>
    <link href="//achillesz.github.io/2015/09/11/inherit.html"/>
    <updated>2015-09-11T23:51:36+08:00</updated>
    <id>//achillesz.github.io/2015/09/11/inherit</id>
    <content type="html">
  
    Son 类实例化一个对象，new 应该需要做几件事，创造一个空对象，执行类函数，类函数的this指向空对象，无返回值，默认返回该对象。
  
  
    生成的实例对象有个constructor，指向类（构造它的）。
  
  
    生成的实例对象应该有个_proto_指向类的原型对象的_proto_
  
  
    每一个函数都应该有一个原型对象，属性constructor,应该指向类自身。类创建的对象的constructor应该与这里的constructor保持一致。
  




如何印证上面所说的？

第一条说明



	function Son() {...</content>
  </entry>
  
  <entry>
    <title>Component关系功能说明</title>
    <link href="//achillesz.github.io/2015/09/11/usage.html"/>
    <updated>2015-09-11T05:51:36+08:00</updated>
    <id>//achillesz.github.io/2015/09/11/usage</id>
    <content type="html">继承关系说明

$.ui.Component --&amp;gt; $.event.EventTarget --&amp;gt; $.Disposable

$.ui.Dialog --&amp;gt; $.ui.Component

	$.ui.Prompt --&amp;gt; $.ui.Dialog
	$.ui.PromptDialog --&amp;gt; $.ui.Dialog





$.ui.AjaxForm &amp;gt; $.ui.Component
$.ui.NumberInput &amp;gt; $.ui.Component
$.ui.Score &amp;gt; $.ui.Component
$.ui.Placehold...</content>
  </entry>
  
  <entry>
    <title>Function.call Function.apply</title>
    <link href="//achillesz.github.io/javascript/2015/09/10/call-apply.html"/>
    <updated>2015-09-10T00:00:00+08:00</updated>
    <id>//achillesz.github.io/javascript/2015/09/10/call-apply</id>
    <content type="html">##内部实现

apply

/**
@param {Object} [thisArg]
@param {Array} [argArray]
@return {*}
*/
Function.prototype.apply = function(thisArg,argArray) {};


#### call

/**
@param {Object} [thisArg]
@param {...*} [args]
@return {*}
*/
Function.prototype.call = function(thisArg,args) {};
Function = {};



###...</content>
  </entry>
  
  <entry>
    <title>linux 下复制粘帖</title>
    <link href="//achillesz.github.io/linux/2015/09/07/vim-cp.html"/>
    <updated>2015-09-07T04:51:36+08:00</updated>
    <id>//achillesz.github.io/linux/2015/09/07/vim-cp</id>
    <content type="html">系统下

  在KDE/Gnome下：
复制命令：Ctrl + C
粘贴命令：Ctrl + V
  在终端下：
复制命令：Ctrl + Shift + C 组合键.
粘贴命令：Ctrl + Shift + V 组合键.
  在控制台下：
复制命令：Ctrl + Insert 组合键　　或　　用鼠标选中即是复制。
粘贴命令：Shift + Insert 组合键　 或　　单击鼠标滚轮即为粘贴


VIM 下
buntu 和mint默认安装的vim是不支持系统剪切、粘贴版的，需要执行以下安装：


	sudo apt-get install vim-gnome




  vim有12个粘贴板...</content>
  </entry>
  
  <entry>
    <title>jQuery type</title>
    <link href="//achillesz.github.io/javascript/jquery/2015/09/07/type.html"/>
    <updated>2015-09-07T04:51:36+08:00</updated>
    <id>//achillesz.github.io/javascript/jquery/2015/09/07/type</id>
    <content type="html">type    你好

type of obj






  
    
      obj
      result1
    
  
  
    
      undefined
      undefined
    
    
      null
      object
    
  


        type: function(obj) {
            if (obj == null) {
                return String(obj);
            }
            // Support: Safari &amp;...</content>
  </entry>
  
  <entry>
    <title>jQuery-Event</title>
    <link href="//achillesz.github.io/javascript/jquery/2015/08/27/jquery-event.html"/>
    <updated>2015-08-27T22:57:36+08:00</updated>
    <id>//achillesz.github.io/javascript/jquery/2015/08/27/jquery-event</id>
    <content type="html">#标题1

##标题2

我是段落

我是引用




  我是引用2


内引用 的的



	function helloWorld() {
		console.log(&#39;hello&#39;);	
	}

</content>
  </entry>
  
  <entry>
    <title>javascript优先级</title>
    <link href="//achillesz.github.io/javascript/2015/08/19/grade.html"/>
    <updated>2015-08-19T18:21:36+08:00</updated>
    <id>//achillesz.github.io/javascript/2015/08/19/grade</id>
    <content type="html">
  
    
      运算符
      描述
    
  
  
    
      . [] ()
      字段访问、数组下标、函数调用以及表达式分组
    
    
      ++ – - ~ ! delete new typeof void
      一元运算符、返回数据类型、对象创建、未定义值
    
    
      * / %
      乘法、除法、取模
    
    
      + - +
      加法、减法、字符串连接
    
    
      « » »&amp;gt;
      移位
    
    
      &amp;lt;...</content>
  </entry>
  
  <entry>
    <title>HTML单引号导致的BUG</title>
    <link href="//achillesz.github.io/work/2015/08/14/bugs.html"/>
    <updated>2015-08-14T22:56:36+08:00</updated>
    <id>//achillesz.github.io/work/2015/08/14/bugs</id>
    <content type="html">需要读取且回传给后端的数据，悲剧的单引号


 
 &amp;lt;input type=&quot;text&quot; id=&quot;classifyPriceData&quot; name=&quot;availableDateSetData&quot; value=&#39;{&quot;title&quot;:&quot;当训象师和大象做朋友——Bobby&#39;s大象之家（成人）&quot;}&#39;/&amp;gt;

 



这样HTML解析的时候无法正确的匹配引号，导致问题。解决方案是如果值需要回传给后端，应在后端给出的值中做转义，如果不需要给后端，可以直接拍到JS的某个属性里。
</content>
  </entry>
  
  <entry>
    <title>票种模块业务</title>
    <link href="//achillesz.github.io/work/2015/08/13/price-chanel.html"/>
    <updated>2015-08-13T22:56:36+08:00</updated>
    <id>//achillesz.github.io/work/2015/08/13/price-chanel</id>
    <content type="html">属性解释


    canusedate
    分类下设置使用日期快
    
    
        
             {title: &quot;&quot;, productId: &quot;2499086813&quot;, beginDate: &quot;2015-08-14&quot;, endDate: &quot;2015-08-30&quot;, weekDays[]: Array[7]…}
        
    


</content>
  </entry>
  
  <entry>
    <title>欢迎来到febbc</title>
    <link href="//achillesz.github.io/jekyll/update/2015/08/04/welcome-to-jekyll.html"/>
    <updated>2015-08-04T06:14:36+08:00</updated>
    <id>//achillesz.github.io/jekyll/update/2015/08/04/welcome-to-jekyll</id>
    <content type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.

To a...</content>
  </entry>
  
  <entry>
    <title>Hello Jekyll!</title>
    <link href="//achillesz.github.io/demo/2014/08/13/hello-jekyll.html"/>
    <updated>2014-08-13T00:00:00+08:00</updated>
    <id>//achillesz.github.io/demo/2014/08/13/hello-jekyll</id>
    <content type="html">测试 h1

测试 h2

测试 h3

测试 h4

测试 h5

测试 h6



这是一个 代码块

这是一个 粗体

这是一个 斜体

TAB缩进是代码块




  &amp;lt; 是引用


都加空行是段落

/* hello world demo */
#include &amp;lt;stdio.h&amp;gt;
int main(int argc, char **argv)
{
        printf(&quot;Hello, World!\n&quot;);
        return 0;
}



下面是表格


  
    
      head1
      head2
      hea...</content>
  </entry>
  

</feed>

---
layout: post
title: "Deferred"
date:   2015-11-04 18:11:36
categories: [jQuery]
tags: [Deferred]
---

如果之前说，`CallBacks` 是某一个时候一次干某些事情，那么 `Deferred` 就是一件事情，不同的时候，怎么干事情。比如代码中分了3个时候，
一个是成功，一个是失败，一个是处理中。因为大部分情况，我们关心这几个就好了。

假设饭熟了，我们要吃饭这件事情。add('吃饭').add('喝汤') add('饭做不了了').add('去别的地方吃') 
add('做饭中').add('还有十分钟可以吃饭了').add('饭吃饭了散步')

我们 `Deferred` 对象有： 
resolove reject notify 相当于各 `callbacks` 的 `fireWith`
done fail progress 是 `add`
resolved rejected 是表示状态


下面源代码执行过程：

申明了一个数组，每一个表示一个回调列表的一些情况。
第一个参数用来作调用，第二个用来做添加，第三个是列表本身。最后有2个状态。
为啥没有第三个状态？

第三个列表表示处理中的一个消息，所以不论 成功或者失败，它都要被锁掉。或者说，消息处理中可以有各种调用，一旦成功，就被 `lock`, 并不会禁掉。 

```js
	            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
 
```

lock 掉的不会再执行。

```js
	            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [context, args.slice ? args.slice() : args];
                    //如果正在回调
                    if (firing) {
                        //将参数推入堆栈，等待当前回调结束再调用
                        stack.push(args);
                    } else { //否则直接调用
                        fire(args);
                    }
                }
                return this;
            },
 
```

但 由于是 `memory` 所以 `add` 的会立即执行

```js
					...	
                    var start = list.length;
                    ...
                   if (firing) {
                        firingLength = list.length;
                        // With memory, if we're not firing then
                        // we should call right away
                    } else if (memory) {
                        //如果options.memory为true，则将memory做为参数，应用最近增加的回调函数
                        firingStart = start;
                        fire(memory);
                    }
   
```
假设通知正在发送消息，而此时执行禁掉操作，执行里面如果还有调用会直接退出。如果执行 add 操作会添加，如果调用中，调整列表长度，从而吧 新增的也添加到执行队列当中。如果已执行完成，那么起始为列表长度。执行 memory 参数的调用
调用完成之后发现 stack 不存在了，然后执行 清空列表操作

```js
			 if (list) {
                if (stack) {
                    if (stack.length) {
                        //从堆栈头部取出，递归fire
                        fire(stack.shift());
                    }
                } else if (memory) { //否则，如果有记忆
                    list = [];
                } else { //再否则阻止回调列表中的回调
                    self.disable();
                }
            }
```
好吧，其实讲了半天Deffered执行机制里面有状态的回调列表默认 each 添加的一些函数。以及之间的联系。

实际上，都得到第三项回调，然后添加，把第二项赋值 add ,第一项添加到 Deffered, 最后吧 promise 添加到 Deffered旧.



```js
    jQuery.extend({

        Deferred: function(func) {
            var tuples = [
                // action, add listener, listener list, final state
                ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                ["notify", "progress", jQuery.Callbacks("memory")]
            ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred(function(newDefer) {
                            jQuery.each(tuples, function(i, tuple) {
                                var action = tuple[0],
                                    fn = jQuery.isFunction(fns[i]) && fns[i];
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[tuple[1]](function() {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise()
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject)
                                            .progress(newDefer.notify);
                                    } else {
                                        newDefer[action + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function(subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = core_slice.call(arguments),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function(i, contexts, values) {
                    return function(value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!(--remaining)) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise()
                            .done(updateFunc(i, resolveContexts, resolveValues))
                            .fail(deferred.reject)
                            .progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        }
 
```
